"""Philosophy context injector for module generation stages."""

from __future__ import annotations

import logging
from pathlib import Path

from amplifier.utils.file_io import read_text

from .enums import PipelineStage

logger = logging.getLogger(__name__)


class PhilosophyInjector:
    """Injects philosophy context into prompts at each stage."""

    def __init__(self, repo_root: Path):
        self.repo_root = repo_root
        self.philosophy_files = {
            "implementation": repo_root / "ai_context" / "IMPLEMENTATION_PHILOSOPHY.md",
            "modular": repo_root / "ai_context" / "MODULAR_DESIGN_PHILOSOPHY.md",
        }
        self._cache = {}

    def _load_philosophy(self, key: str) -> str:
        """Load philosophy content with caching."""
        if key in self._cache:
            return self._cache[key]

        file_path = self.philosophy_files.get(key)
        if not file_path or not file_path.exists():
            logger.warning(f"Philosophy file not found: {file_path}")
            return ""

        try:
            content = read_text(file_path)
            self._cache[key] = content
            return content
        except Exception as e:
            logger.error(f"Failed to load philosophy file {file_path}: {e}")
            return ""

    def get_stage_context(self, stage: PipelineStage) -> str:
        """Get philosophy context appropriate for a specific stage."""
        if stage == PipelineStage.PARSE:
            # No philosophy needed for parsing
            return ""

        if stage == PipelineStage.PLAN:
            return self._get_planning_context()

        if stage in [PipelineStage.GENERATE, PipelineStage.VERIFY_CONTRACT]:
            return self._get_implementation_context()

        if stage == PipelineStage.TEST:
            return self._get_testing_context()

        return ""

    def _get_planning_context(self) -> str:
        """Get philosophy context for planning stage."""
        # Load modular philosophy but use hardcoded context for now
        # Could incorporate loaded content in future: self._load_philosophy("modular")

        # Extract key planning principles
        context = """
# MODULE DESIGN PHILOSOPHY

Follow these critical principles when planning the module:

## Bricks & Studs Philosophy
- Think of the module as a self-contained "brick" with clear connection points ("studs")
- The module must be independently regeneratable without breaking connections
- All code, tests, and fixtures must live inside the module directory
- Public interface (studs) must remain stable even if internals change

## Ruthless Simplicity
- Start with the simplest implementation that meets current needs
- Avoid future-proofing and hypothetical requirements
- Every abstraction must justify its existence
- Code you don't write has no bugs

## Module Structure Requirements
- Single responsibility: ONE clear purpose
- Clear contracts: Well-defined inputs, outputs, and side effects
- Self-contained: Everything needed is in the module directory
- Regeneratable: Can be rebuilt from spec without breaking other modules

Remember: We're building software with AI assistance. Make the module boundaries clear
and the implementation straightforward. The module should be a complete, working unit
that can be understood and regenerated independently.
"""
        return context

    def _get_implementation_context(self) -> str:
        """Get philosophy context for implementation/generation stage."""
        # Load implementation philosophy but use hardcoded context for now
        # Could incorporate loaded content in future: self._load_philosophy("implementation")

        context = """
# IMPLEMENTATION PHILOSOPHY

Critical implementation guidelines:

## Core Principles
1. **Ruthless Simplicity**: Keep everything as simple as possible, but no simpler
2. **Minimal Abstractions**: Every layer must justify its existence
3. **Start Minimal**: Begin with simplest implementation that works
4. **No Future-Proofing**: Don't build for hypothetical requirements

## Module Implementation Rules
- **Self-Contained**: All module code in the module directory
- **Clear Public Interface**: Define __all__ with only public exports
- **Working Code Only**: No stubs, no NotImplementedError, no TODOs
- **Direct Implementation**: Avoid unnecessary wrappers and adapters

## Code Structure
- Put public interface in __init__.py
- Use models.py for data structures
- Main logic in core.py (or domain-specific name like synthesizer.py)
- Internal helpers in utils.py
- All tests in tests/ subdirectory

## Quality Requirements
- Every function must actually work
- Handle common errors robustly
- Provide clear error messages
- Write code that's easy to understand and regenerate

Remember: This module will be regenerated by AI. Keep it simple, clear, and self-contained.
Focus on making it work correctly rather than making it clever.
"""
        return context

    def _get_testing_context(self) -> str:
        """Get philosophy context for testing stage."""
        return """
# TESTING PHILOSOPHY

## Test Requirements
- Focus on behavior, not implementation details
- Test the public interface (contract validation)
- Include both success and failure cases
- Keep tests simple and readable

## Test Structure
- Unit tests for complex logic
- Contract validation tests for public interface
- Integration tests for external dependencies
- All tests must be runnable in isolation

## Key Principles
- Tests document expected behavior
- Fast feedback is critical
- Test at the right level of abstraction
- Prefer clarity over DRY in tests

Remember: Tests ensure the module meets its contract and can be safely regenerated.
"""

    def inject_into_prompt(self, prompt: str, stage: PipelineStage) -> str:
        """Inject philosophy context into a prompt."""
        context = self.get_stage_context(stage)
        if not context:
            return prompt

        # Insert philosophy after initial instruction but before specs
        if "===" in prompt:
            # Find first === marker
            parts = prompt.split("===", 1)
            return parts[0] + context + "\n\n===" + parts[1]
        # Just prepend if no clear structure
        return context + "\n\n" + prompt

    def get_full_philosophy(self) -> str:
        """Get complete philosophy documentation."""
        impl = self._load_philosophy("implementation")
        modular = self._load_philosophy("modular")

        return f"""
# COMPLETE PHILOSOPHY GUIDE

## Modular Design Philosophy
{modular}

## Implementation Philosophy
{impl}
"""
