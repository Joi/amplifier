# Amplifier v0.2.0: What Changed and Why

_A comprehensive guide to understanding the evolution from v0.1.0 to v0.2.0_

## Table of Contents
- [Executive Summary](#executive-summary)
- [The Big Picture: Paradigm Shift](#the-big-picture-paradigm-shift)
- [Major Changes](#major-changes)
- [Architectural Improvements](#architectural-improvements)
- [Team Collaboration & Community Ecosystem](#team-collaboration--community-ecosystem)
- [User Experience Improvements](#user-experience-improvements)
- [Migration Path](#migration-path)

---

## Executive Summary

Amplifier v0.2.0 represents a fundamental architectural evolution from a **workspace you work inside** to a **tool you bring to your projects**. This change enables Amplifier to integrate seamlessly into existing projects while maintaining all its powerful features.

**Key Statistics:**
- 133 files changed
- 5,286 insertions, 1,446 deletions
- New CLI with 10+ commands
- Introduction of mode system for environment switching
- Unified configuration system

> **⚠️ Current Limitation**: While v0.2.0 provides the architecture for "bring Amplifier to your projects," Python environment isolation is not yet fully implemented. Amplifier's tools currently use the project's Python environment, which can cause dependency conflicts. **For now, we still recommend working within an Amplifier repository** (`git clone` + work inside it). Full project integration with isolated environments will come in a future release.

---

## The Big Picture: Conceptual Shifts

Amplifier v0.2.0 introduces several fundamental conceptual changes that work together to create a more flexible, collaborative, and maintainable system:

### 1. **From Intermingled to Separated Workspaces**
Create clear boundaries between Amplifier (the tool and its resources) and your projects (your work), preventing confusion about what belongs where.

### 2. **From Mixed to Separated Configuration**
Separate Amplifier configuration from project configuration, eliminating environment pollution and conflicts.

### 3. **From Monolithic to Layered Architecture**
Separate stable core (package) from evolving resources (directory) from custom changes (overlay).

### 4. **From Fork-Based to Overlay-Based Customization**
Enable non-destructive customization where user changes overlay official resources without conflicts.

### 5. **From Individual to Collaborative**
Create clear paths for individual experimentation → team sharing → community contribution.

### 6. **From Centralized to Distributed Resources**
Shift from embedded resources to git-fetchable, versioned directories that can be shared and updated independently.

These shifts work together to enable **team collaboration** while maintaining **individual flexibility**, creating an ecosystem where **community knowledge compounds** rather than fragments.

---

## Major Changes

### 1. Package Distribution Model: "Bring Amplifier to Your Projects"

**The Paradigm Shift:**

**v0.1.0 Approach:**
```bash
git clone https://github.com/microsoft/amplifier.git
cd amplifier
# Copy your project into Amplifier or work with --add-dir
```
*Problem:* Inverted the natural workflow. Your projects should be primary, tools secondary.

**v0.2.0 Vision:**
```bash
cd /path/to/your/project
uv add amplifier
amplifier init
amplifier mode set amplifier-dev
```
*Solution:* Amplifier becomes a package you install anywhere, respecting your project boundaries.

> **⚠️ Implementation Status**: The architecture for this paradigm is fully implemented in v0.2.0, but Python environment isolation is not yet complete. For now, continue using the traditional approach (`git clone amplifier` + work inside it) to avoid dependency conflicts. The architecture is ready; isolated tool execution is coming in a future release.

**What Changed:**
- Amplifier is now installable via `uv add amplifier`
- Projects get Amplifier capabilities without becoming an Amplifier workspace
- Resources distributed via git-fetchable directories
- CLI commands replace Makefile-based workflows

**Why This Matters:**
- **Non-invasive integration**: Your project structure remains yours
- **Version control clarity**: Amplifier updates don't interfere with your git history
- **Multi-project support**: Install Amplifier in all your projects independently
- **Tool semantics**: Amplifier is positioned as a tool, not a workspace

**Technical Implementation:**
- New `amplifier init` command creates `.amplifier/` directory
- Resources fetched from `git+microsoft/amplifier/directory`
- Configuration in `.amplifier/config.yaml`
- Mode system activates appropriate resources for each project

### 2. Mode System

**What Changed:**
- Introduced "modes" - pre-configured development environments
- Each mode bundles: agents, commands, contexts, tools, hooks
- Switch modes instantly: `amplifier mode set <mode-name>`

**Why This Matters:**
- **Context-appropriate AI behavior**: Backend mode vs frontend mode vs data science mode
- **Team standardization**: Share modes to standardize team workflows
- **Experimentation**: Try different agent configurations without committing

**Technical Implementation:**
- Modes defined in `.amplifier/directory/modes/`
- Each mode has `amplifier.yaml` manifest declaring resources
- Mode activation performs several operations:
  1. Creates symlinks for agents, commands, contexts, and tools to `.claude/` and `amplifier-context/`
  2. Applies overlay resolution (custom files override official ones)
  3. Updates `.claude/settings.json` with mode-specific settings (permissions, hooks, MCP servers)
  4. Symlinks mode-specific `CLAUDE.md` and `AGENT.md` to project root
  5. Saves mode state to `.amplifier/state.json`
- Custom modes via `.amplifier.local/directory/modes/`

**Example Mode Manifest:**
```yaml
version: 0.1.0
agents:
  - zen-architect.md
  - bug-hunter.md
  - security-guardian.md
commands:
  - commit.md
  - ultrathink-task.md
contexts:
  - IMPLEMENTATION_PHILOSOPHY.md
  - AMPLIFIER_CLI.md
tools:
  - hook_precompact.py
mcp:
  - deepwiki
  - browser-use
```

### 3. Unified Configuration System

**What Changed:**
- Eliminated `.env` files entirely
- All configuration in `.amplifier/config.yaml`
- Structured YAML with proper typing and validation
- Central `config_manager` for all configuration access

**Why This Matters:**
- **Separation of concerns**: Amplifier configuration no longer pollutes your project's environment
- **No environment conflicts**: Your project's `.env` remains solely for your project's settings
- **Single source of truth**: All Amplifier settings in one clear location
- **Type safety**: Configuration validated at load time
- **Better documentation**: YAML is self-documenting
- **Environment variable support**: Still available as `AMPLIFIER__NESTED__KEY=value` when needed

**Before (v0.1.0):**
```bash
# .env
AMPLIFIER_DATA_DIR=~/data
ANTHROPIC_API_KEY=sk-...
```

**After (v0.2.0):**
```yaml
# .amplifier/config.yaml
directory: git+microsoft/amplifier/directory
paths:
  data_dir: ~/OneDrive/amplifier/data
  content_dirs:
    - .data/content
models:
  default: claude-sonnet-4-20250514
  fast: claude-3-5-haiku-20241022
```

**Configuration Overrides:**
Environment variables can still override config file settings using the `AMPLIFIER__` prefix with double underscores for nesting:
```bash
# Override data directory
export AMPLIFIER__PATHS__DATA_DIR=/custom/path

# Override default model
export AMPLIFIER__MODELS__DEFAULT=claude-opus-4-20250514
```
This allows temporary overrides without modifying the config file, useful for CI/CD or testing.

### 4. Custom Directory Overlay System

**What Changed:**
- Added `.amplifier.local/directory/` for user customizations
- Overlay resolution: official → local → active
- `amplifier directory freeze` to copy official files for editing

**Why This Matters:**
- **Non-destructive customization**: Override without modifying originals
- **Gitignore-friendly**: Local customizations stay local by default
- **Team sharing**: Version control `.amplifier.local/` separately if desired
- **Progressive customization**: Start simple, customize as needed

**Technical Implementation:**
```python
# Overlay resolution in amplifier/overlay.py
def create_overlay_resolver(local_dir, official_dir):
    def resolve(path):
        local_path = local_dir / path.relative_to(official_dir)
        if local_path.exists():
            return local_path  # Local override
        return path  # Official fallback
    return resolve
```

### 5. Amplifier CLI

**What Changed:**
Moved from `make` commands to proper CLI:

| Old (v0.1.0) | New (v0.2.0) |
|--------------|--------------|
| `make install` | `amplifier init` |
| `make worktree-create` | `amplifier worktree create` |
| `make transcript-list` | `amplifier transcript list` |
| N/A | `amplifier mode set <mode>` |
| N/A | `amplifier directory fetch` |

**Why This Matters:**
- **Better UX**: Proper help text, argument parsing, error messages
- **Composability**: CLI commands work with shell scripts and automation
- **Discoverability**: `amplifier --help` shows all capabilities
- **Cross-platform**: No reliance on `make` being available

**Implementation Highlights:**
- `amplifier/cli.py` - 806 lines implementing all commands
- Uses Click for argument parsing and command groups
- Proper error handling and user feedback
- Integration with git, uv, and Claude Code

### 6. Directory Structure Reorganization

**What Changed:**

**Before (v0.1.0):**
```
.claude/
  agents/
  commands/
  tools/
ai_context/
  (various context files)
```

**After (v0.2.0):**
```
.amplifier/
  config.yaml
  directory/          # Official resources
    agents/
    commands/
    contexts/
    tools/
    modes/
  .amplifier.local/   # Custom overrides (gitignored)
    directory/
      agents/
      contexts/
```

**Why This Matters:**
- **Cleaner namespace**: `.amplifier/` clearly indicates Amplifier-specific files
- **Mode support**: Directory structure enables mode switching
- **Overlay system**: Separation of official and custom resources
- **Git-ignored customization**: Local overrides don't pollute git

### 7. Modular Python Implementation

**What Changed:**
- Introduced `amplifier/cli.py` (main CLI)
- Created `amplifier/config/config.py` (configuration management)
- Added `amplifier/directory_fetcher.py` (git-based resource fetching)
- Implemented `amplifier/overlay.py` (custom directory resolution)
- Refactored `amplifier/transcript/` (transcript management)
- Expanded `amplifier/worktree/` (worktree operations)

**Why This Matters:**
- **Testability**: Modular code is easier to test
- **Maintainability**: Clear separation of concerns
- **Reusability**: Modules can be used independently
- **AI-friendly**: Well-structured code for AI analysis

**Key Modules:**

```python
# amplifier/config/config.py
class AmplifierConfig:
    """Central configuration management"""
    directory: str
    paths: PathsConfig
    models: ModelsConfig
    # ... with validation and defaults

# amplifier/cli.py
@click.group()
def mode():
    """Mode management commands"""

@mode.command(name="set")
def set_cmd(mode_name: str):
    """Set the current mode"""
    # Unsets existing mode first
    # Validates mode exists
    # Creates symlinks
```

### 8. Git-Based Directory Distribution

**What Changed:**
- Directories fetched from git repositories
- Supports GitHub shorthand: `git+microsoft/amplifier/directory`
- Branch support: `git+microsoft/amplifier/directory@v0.2.0`
- Local directory support: `/path/to/custom/directory`

**Why This Matters:**
- **Centralized updates**: `amplifier directory fetch` gets latest resources
- **Version pinning**: Use specific branches/tags for stability
- **Community sharing**: Easy to share custom directories
- **Offline support**: Cached locally after first fetch

**Configuration:**
```yaml
# Use official directory
directory: git+microsoft/amplifier/directory

# Pin to specific version
directory: git+microsoft/amplifier/directory@v0.2.0

# Use local directory
directory: /home/user/my-amplifier-directory
```

---

## Architectural Improvements

### From Monolithic to Composable

**v0.1.0 Architecture:**
- Single repository containing everything
- Fixed structure with limited customization
- Configuration scattered across multiple files
- Tight coupling between Amplifier and user projects

**v0.2.0 Architecture:**
- Package-based distribution
- Mode system for dynamic configuration
- Overlay system for composable customization
- Clear separation between Amplifier and user projects

### Alignment with "Bricks and Studs" Philosophy

The mode system perfectly embodies modular design:

**Each mode is a brick** - Self-contained directory with manifest declaring its contract. The "studs" are the standardized `.claude/` structure.

**Contract Definition:**
```yaml
# Mode manifest is the contract
agents: ["zen-architect", "bug-hunter"]
commands: ["commit", "ultrathink-task"]
contexts: ["IMPLEMENTATION_PHILOSOPHY.md"]
```

**Isolation:** Modes live in separate directories, exposing only manifest

**Regeneration:** Switching modes completely regenerates `.claude/` rather than patching

**Parallel Variants:** Multiple modes coexist, enabling A/B testing of environments

### Ruthless Simplicity

v0.2.0 demonstrates simplicity through:

1. **Simple file operations**: Modes use symlinks, not complex APIs
2. **Clear contracts**: YAML manifests, not code-based configuration
3. **Minimal abstractions**: Overlay system is just directory merging
4. **Direct tools**: CLI commands do one thing well

**Example - Mode Switching:**
```python
def set_mode(mode: str):
    # 1. Validate mode exists
    manifest = get_mode_manifest(mode)

    # 2. Create symlinks from directory to .claude/
    for collection in ["agents", "commands", "tools"]:
        for item in manifest[collection]:
            src = DIRECTORY / collection / item
            dst = CLAUDE_DIR / collection / item
            dst.symlink_to(src)

    # 3. Save state
    state["mode"] = mode
```

Simple file operations, no complex state management.

### Future-Proof Foundation

v0.2.0 creates a platform for growth:

- **Extensibility without modification**: New modes don't require core changes
- **Community contribution**: Share modes via git repositories
- **AI-ready**: Clear contracts make AI generation of modes feasible
- **Progressive disclosure**: Simple start, advanced features as needed

---

## Team Collaboration & Community Ecosystem

One of the most important aspects of v0.2.0 is how it enables **team collaboration** and **community contribution** through a three-layer architecture with different stability guarantees.

### Three-Layer Architecture

#### **Layer 1: Stable Core (Amplifier Package)**
The `amplifier` Python package provides the stable foundation:
- Configuration system (`amplifier/config/`)
- CLI commands (`amplifier mode`, `amplifier directory`, etc.)
- Directory fetcher, overlay resolver, mode manager
- **Stability**: Semantic versioning, backwards compatibility
- **Update frequency**: Infrequent, breaking changes only with major versions
- **Ownership**: Core team maintains
- **Update method**: `uv add amplifier` or `uv sync`

**Philosophy**: The core should be **boring and stable**. It provides the machinery but rarely needs to change.

#### **Layer 2: Official Directory (Curated Resources)**
The official directory contains evolving best practices:
- Agents, commands, contexts, tools, modes
- Lives at `git+microsoft/amplifier/directory`
- **Stability**: Changes frequently but non-breaking (new resources added, existing ones improved)
- **Update frequency**: Weekly/monthly as new patterns emerge
- **Ownership**: Maintainers + community contributions via PR
- **Update method**: `amplifier directory fetch`

**Philosophy**: The directory should **learn and improve** based on community discoveries.

#### **Layer 3: User Customizations (Local Overlay)**
Individual or team-specific customizations:
- Lives in `.amplifier.local/directory/`
- Custom modes, modified agents, team-specific contexts
- **Stability**: Whatever the user/team wants
- **Update frequency**: Continuous, per user/team needs
- **Ownership**: Individual users or teams
- **Sharing**: Via git repos, copy-paste, or PRs back to official

**Philosophy**: Users should be able to **customize freely** without breaking updates.

### The Collaboration Flow

#### **Individual → Team Sharing**

```bash
# Alice discovers a better security pattern
edit .amplifier.local/directory/agents/security-guardian.md

# Works great! Share with team
git add .amplifier.local/
git commit -m "Add OWASP checks to security agent"
git push

# Bob pulls and immediately gets the customization
git pull
# Alice's customization automatically overlays official version
# Team now has consistent security practices
```

#### **Team → Official Contribution**

```bash
# Team has developed an excellent custom mode
.amplifier.local/directory/modes/fintech-compliance/
  ├── amplifier.yaml
  ├── AGENTS.md
  └── contexts/
      ├── FINANCIAL_REGULATIONS.md
      └── AUDIT_REQUIREMENTS.md

# Submit PR to official directory
# If accepted, becomes available to everyone

# Team can then either:
#   - Delete local version (use official)
#   - Keep local with team-specific tweaks (overlay continues)
```

#### **Official → Users (Preserving Customizations)**

```bash
# Official directory updates with new agents and modes
amplifier directory fetch

# User's customizations in .amplifier.local/ are preserved
# Overlay system intelligently merges:
#   ✓ New official agents/modes become available
#   ✓ User's local overrides continue to work
#   ✓ No conflicts because local always wins
#   ✓ Users can selectively adopt official improvements
```

### Why This Matters for Teams

#### **1. Clear Contribution Path**

The architecture creates a natural progression:
1. **Experiment locally** (`.amplifier.local/`) - Safe, personal sandbox
2. **Share with team** (commit `.amplifier.local/`) - Team benefits
3. **Propose to community** (PR to official directory) - Everyone benefits
4. **Official adoption** (merged into official) - Becomes standard practice

This turns **individual learning** into **community knowledge** without friction.

#### **2. Modes as Shareable Units**

Teams can package entire development environments:

```yaml
# .amplifier.local/directory/modes/backend-api-team/amplifier.yaml
version: 0.1.0
agents:
  - zen-architect.md
  - database-architect.md
  - api-contract-designer.md
  - security-guardian.md
commands:
  - commit.md
  - review-changes.md
contexts:
  - TEAM_API_STANDARDS.md
  - DATABASE_CONVENTIONS.md
  - SECURITY_CHECKLIST.md
tools:
  - team_code_review_hook.py
mcp:
  - deepwiki
```

Share this mode and everyone gets:
- Same agent configurations
- Same development standards
- Same quality checks
- Instant onboarding for new team members

#### **3. No Fork Explosion**

**Old model (v0.1.0):**
- Team forks Amplifier repository
- Makes customizations in fork
- Official Amplifier updates → difficult to merge
- Each team has divergent Amplifier versions
- Community improvements don't flow back

**New model (v0.2.0):**
- Teams overlay customizations on official directory
- Official updates never conflict with customizations
- Teams can selectively adopt official improvements
- Successful team patterns can be contributed back
- **The system learns and improves over time**

#### **4. Gradual Integration & Evolution**

Teams can evolve their practices organically:

```
Week 1: Use vanilla mode
Week 4: Add team customizations in .amplifier.local/
Month 3: Develop custom team mode
Month 6: Contribute successful patterns to official
Year 1: Team's contributions benefit entire community
```

The architecture supports **continuous improvement** without requiring upfront perfection.

#### **5. Multi-Team Organizations**

Large organizations can standardize across teams:

```
# Organization repo: company-amplifier-directory
modes/
  ├── backend-standards/
  ├── frontend-standards/
  ├── mobile-standards/
  └── data-science-standards/

# Teams configure:
# .amplifier/config.yaml
directory: git+company/amplifier-directory

# All teams get company standards
# Each team can still customize locally
```

### Community Ecosystem Benefits

#### **Distributed Innovation**
- Anyone can experiment locally
- Best practices emerge organically
- Successful patterns get contributed back
- Official directory becomes **distilled wisdom**

#### **Stable Foundation**
- Core rarely breaks
- Resources evolve rapidly
- Users control their update cadence
- **Stability where it matters, innovation where it helps**

#### **Network Effects**
- More users → more patterns discovered
- More contributions → better official directory
- Better directory → more value for everyone
- **Positive feedback loop**

### Example: Mode Evolution Timeline

```
Month 1: User creates local security-focused mode
Month 2: Team adopts and improves it
Month 3: PR to official directory
Month 4: Merged, available to all users
Month 5: Other teams customize for their domains
Month 6: Improvements flow back to official
Month 12: Security mode becomes standard best practice
```

This is how **community knowledge compounds** rather than fragments.

---

## User Experience Improvements

### 1. Zero Disruption Integration

**Before:**
```bash
git clone amplifier
cd amplifier
# Now I'm in Amplifier's repository
# My project needs to be copied here or accessed via --add-dir
```

**After:**
```bash
cd my-project
uv add amplifier
amplifier init
# I'm still in my project, Amplifier is just a tool
```

**Impact:** Amplifier respects your project's primary status.

### 2. Instant Environment Switching

```bash
# Working on backend API
amplifier mode set backend-dev
# All backend-focused agents, contexts, tools activated

# Switching to frontend work
amplifier mode set frontend-dev
# Different agents, contexts, tools - instant reconfiguration
```

**Impact:** AI assistant adapts to your current context.

### 3. Experimentation Without Commitment

```bash
# Try customization locally
amplifier directory freeze
edit .amplifier.local/directory/agents/custom-agent.md

# If it works, keep it
# If not, delete .amplifier.local/ - no harm done
```

**Impact:** Safe experimentation encourages customization.

### 4. Centralized Updates

```bash
# Get latest Amplifier resources
amplifier directory fetch

# Your customizations in .amplifier.local/ are preserved
# Overlay system merges official updates with your changes
```

**Impact:** Easy updates without losing customizations.

### 5. Project Isolation

Each project has independent:
- Mode selection
- Configuration
- Local customizations
- Amplifier version

**Impact:** Different projects can use Amplifier differently.

---

## Migration Path

v0.2.0 provides clear migration support:

### 1. Migration Command
```bash
/amplifier-migrate-v0.2.0
```
Interactive command guides you through migration.

### 2. Documentation
- `MIGRATING_FROM_v0.1.0.md` - Step-by-step guide
- `docs/CONFIGURATION_MIGRATION.md` - Configuration details
- Command reference table in README

### 3. Backward Compatibility
- Environment variables still work: `AMPLIFIER__PATHS__DATA_DIR`
- `make` commands still available (now call CLI)
- Gradual migration possible

---

## Technical Trade-offs

### Complexities Introduced

1. **Learning Curve**: Users must understand modes, overlays, directories
   - *Mitigation:* Sensible defaults, progressive disclosure

2. **Symlink Management**: Mode switching requires filesystem operations
   - *Mitigation:* Automatic mode unsetting, clear error messages

3. **Git Dependency**: Directory fetching requires git
   - *Mitigation:* Git universally available, local directories supported

4. **Configuration Discovery**: Overlay makes file origin less obvious
   - *Mitigation:* `amplifier directory freeze --verbose` shows sources

5. **No Version Management for Directory Items**: Mode manifests reference agents/commands/contexts by name only, without version numbers
   - Current state: `agents: ["zen-architect.md"]` assumes latest version
   - *Issue:* Breaking changes to directory items can break modes that depend on them
   - *Current mitigation:* Accepted limitation; official directory maintains compatibility
   - *Future solution:* May introduce versioned dependencies (e.g., `zen-architect.md@v2.1`) or other dependency management mechanism
   - *Why we accept this:* Unblocks team collaboration now; versioning can be added later without breaking architecture

6. **Python Environment Isolation Not Complete**: Amplifier tools currently use project's Python environment
   - *Issue:* Can cause dependency conflicts with project dependencies
   - *Current mitigation:* Recommend working within Amplifier repository for now
   - *Future solution:* Isolated tool execution environments
   - *Why we accept this:* Architecture is ready; implementation detail to be solved

### Justified Complexity

These complexities are **proportional to value delivered**:
- Flexibility to adapt to different workflows
- Composability for sharing and reuse
- Isolation for multi-project work
- Extensibility for community contributions

---

## Conclusion

Amplifier v0.2.0 transforms from a workspace to a tool, from static to dynamic, from monolithic to composable. This evolution enables:

✅ **Non-invasive integration** into existing projects
✅ **Context-aware AI** through mode switching
✅ **Safe experimentation** via overlay system
✅ **Easy updates** while preserving customizations
✅ **Community sharing** through git-based distribution

The architecture embodies **ruthless simplicity** - directory management and symlinks - while enabling **emergent complexity** through composition. This foundation supports Amplifier's future without requiring architectural rewrites.

**The result:** Amplifier amplifies your projects, not constrains them.

---

## References

- Migration guide: `MIGRATING_FROM_v0.1.0.md`
- Configuration details: `docs/CONFIGURATION_MIGRATION.md`
- Mode system: `.amplifier/directory/modes/`
- CLI implementation: `amplifier/cli.py`
- Overlay system: `amplifier/overlay.py`
